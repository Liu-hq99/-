## 前言

大家好，我是chenzilin。众所周知，面试是我们通往其他更高平台的必经之路之一，前段时间刚好在查漏补缺，经过1个多月的爆肝，我整理了一份前端史上最全的面试题（附答案）！本面试题面向所有前端攻城狮，希望这份面试题能给各位看官查漏补缺，帮助各位看官通往更高的平台。

这份面试题会**持续更新优化**，如果大佬们有好的题目或答案，可以通过评论区或[提PR](https://github.com/qaz624824554/blog)的方式告诉我，我将进行同步更新~

每个栏目分为**Easy**（简单）、**Medium**（中等）、**Hard**（困难）三种难度任供各位看官选择。

如果文中有任何错误，欢迎👏🏻大佬们在评论区指正，也可以通过[提PR](https://github.com/qaz624824554/blog)的方式，我会定期进行修改~



**码字不义，你的点赞、评论、收藏、关注，都将成为我创作的动力！！！**

> 未经允许，请勿转载，谢谢。



以下是整体的目录结构

```
├── HTML
├── CSS
├── JavaScript
├── TypeScript
├── Node
├── 浏览器
├── MVVM框架
│   ├── Vue
│   ├── React
│   ├── Angular
├── 前端工程化
├── 前端优化
├── 前端监控
├── 前端安全
├── 跨端开发
│   ├── 微信小程序
│   ├── React Native
│   ├── Flutter
│   ├── Uniapp
├── 计算机基础
├── 计算机网络
├── 数据结构和算法
├── 设计模式
├── 测试
├── 手写函数
```




## HTML

### ⭐️Easy

#### DOCTYPE有什么用？

​	告诉浏览器处理的是什么，用什么模式来处理。

#### img标签的title和alt属性有什么区别

####  简述一下src与href的区别

​	href用于建立页面与外部资源的关系，不会阻塞dom解析，src用于替代这个元素，会阻塞dom解析

#### H5和H4有什么不同？

​	H5引入原生多媒体支持，引入canvas，引入语义化标签等



### ⭐️⭐️Medium

#### html解析过程？

#### SVG和CANVAS的区别？

#### script标签中defer 和 async 的区别 ?

#### style标签prefetch和preload区别？



### ⭐️⭐️⭐️Hard



<hr />

## CSS

### ⭐️Easy

#### CSS 属性是否区分大小写？

​	不区分大小写

#### CSS的盒模型？

#### link与@import的区别？

#### CSS 选择器的优先级是如何计算的？



### ⭐️⭐️Medium

#### 请阐述块格式化上下文（Block Formatting Context）及其工作原理

#### 请阐述z-index属性，并说明如何形成层叠上下文（stacking context）

#### CSS 有哪些继承属性

#### 有哪些清除浮动的技术，都适用哪些情况？

#### 响应式布局有哪些

#### 讲一下三栏布局实现？圣杯布局、双飞翼布局和flex布局



### ⭐️⭐️⭐️Hard




<hr />

## JavaScript

### ⭐️Easy

#### 什么是闭包？

##### let const var比较

#### offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别

#### mouseover/mouseout 与 mouseenter/mouseleave 的区别与联系

#### isNaN与Number.isNaN的区别



### ⭐️⭐️Medium

#### js有哪些内置对象？

#### 如何理解作用域、作用域链和执行上下文？

#### 如何创建一个没有 prototype(原型)的对象？

#### 说说对原型链的理解

##### JSON.stringify有什么缺点？

##### for...in 和 for...of的区别?

#### new操作符都做了什么

#### 类数组和数组的区别，dom 的类数组如何转换成数组

#### 介绍下 Promise 的特性、优缺点

#### DOM事件机制，怎么阻止事件捕获

#### 说一下事件循环机制Event Loop

#### esm和commonjs的区别

#### 解释下栈内存和堆内存？

#### 箭头函数与普通函数区别

#### 如何理解回流和重绘

#### 讲讲this



### ⭐️⭐️⭐️Hard

##### 说下JS垃圾回收与V8垃圾回收的区别



<hr />

## TypeSCript

### ⭐️Easy

#### type和interface的区别

#### 说说枚举的用法

### ⭐️⭐️Medium



### ⭐️⭐️⭐️Hard



<hr />

## Node

### ⭐️Easy



### ⭐️⭐️Medium

#### require一个模块时的查找过程

#### 如何理解中间件



### ⭐️⭐️⭐️Hard



<hr />

## 浏览器

### ⭐️Easy

#### 常见的浏览器内核有哪些?

#### DOMContentLoaded 与 load 的区别 ?

#### SPA单页应用的优缺点？

#### CSS加载会造成阻塞吗



### ⭐️⭐️Medium

#### 浏览器的主要组成部分是什么？

#### 为什么JS会阻塞页面加载

#### 说一说你对Cookie localStorage sessionStorage的理解

#### 讲讲浏览器缓存

#### 说一说从输入URL到页面呈现发生了什么？

#### 谈一谈你对重排和重绘理解

#### 谈一谈跨域，同源策略，以及跨域解决方案

#### 前端如何进行seo优化

#### requestAnimationFrame与requestIdleCallback区别



### ⭐️⭐️⭐️Hard

#### 浏览器的进程和线程

#### SSR的实现原理？




<hr />

## MVVM框架

### Vue

#### ⭐️Easy

##### 为什么 data 在组件内必须是函数，而 vue 的根实例则没有此限制？

##### vue 组件之间的通信

##### vue2和vue3的生命周期分别有哪些？

##### v-show与v-if区别

#### ⭐️⭐️Medium

##### 双向绑定的原理？

##### props 和 data 的优先级谁高？

##### 说下整个vue的渲染过程？

##### 说下nextTick原理？

#### ⭐️⭐️⭐️Hard

##### 你怎么理解 vue 中的 diff 算法？



### React

#### ⭐️Easy

✍️待补充

#### ⭐️⭐️Medium

✍️待补充

#### ⭐️⭐️⭐️Hard

✍️待补充



### 通用

#### ⭐️Easy

##### MVC和MVVM框架区别？

#### ⭐️⭐️Medium

✍️待补充

#### ⭐️⭐️⭐️Hard

✍️待补充



<hr />

## 前端工程化

### ⭐️Easy

✍️待补充



### ⭐️⭐️Medium

#### webpack 做过哪些优化，开发效率方面、打包策略方面等等

#### webpack中Loader和Plugins的区别

#### webpack plugins原理

#### webpack 热更新原理

#### webpack tree shaking原理

#### 动态导入原理

#### 谈谈你对source map的理解？

#### webpack中bundle、chunk、module的区别

#### webpack5新特性

#### npm管理痛点

#### 为什么 Vite 启动这么快



### ⭐️⭐️⭐️Hard

✍️待补充



<hr />

## 前端优化

### ⭐️Easy

✍️待补充

### ⭐️⭐️Medium

#### 前端常见性能优化手段？

### ⭐️⭐️⭐️Hard

✍️待补充



<hr />

## 前端监控

### ⭐️Easy

✍️待补充

### ⭐️⭐️Medium

#### 前端如何做性能监控、异常监控？

### ⭐️⭐️⭐️Hard

✍️待补充



<hr />

## 前端安全

### ⭐️Easy

✍️待补充

### ⭐️⭐️Medium

#### 谈一谈你对XSS攻击理解

#### 谈一谈你对CSRF攻击理解

#### 谈谈你对sql注入的理解

### ⭐️⭐️⭐️Hard

✍️待补充

<hr />

## 跨端开发

### 微信小程序

#### ⭐️Easy

#### ⭐️⭐️Medium

#### ⭐️⭐️⭐️Hard

### React Native

#### ⭐️Easy

✍️待补充

#### ⭐️⭐️Medium

✍️待补充

#### ⭐️⭐️⭐️Hard

✍️待补充

<hr />

## 计算机基础

### ⭐️Easy

#### 进程与线程的区别

### ⭐️⭐️Medium

#### 进程通信的几种方式

### ⭐️⭐️⭐️Hard

✍️待补充



<hr />

## 计算机网络

### ⭐️Easy

### ⭐️⭐️Medium

#### TCP中三次握手和四次挥手的含义

### ⭐️⭐️⭐️Hard



<hr />

## 数据结构和算法

### ⭐️Easy

#### 二叉树的遍历有几种方法？

### ⭐️⭐️Medium

#### 斐波那契数列实现

### ⭐️⭐️⭐️Hard

✍️待补充



<hr />

## 设计模式

### ⭐️Easy

✍️待补充

### ⭐️⭐️Medium

#### 谈谈常见的设计模式？

### ⭐️⭐️⭐️Hard

✍️待补充



<hr />

## 测试

### ⭐️Easy

✍️待补充

### ⭐️⭐️Medium

### ⭐️⭐️⭐️Hard

✍️待补充



<hr />

## 手写函数

### ⭐️Easy

#### 防抖debounce

```javascript
const debounce = (fn, ms = 1000) => {
  let timer;
  return function (...args) {
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, ms);
  };
};
```

#### 节流throttle

```javascript
const throttle = (fn, ms = 1000) => {
  let flag = true;
  return function (...args) {
    if (!flag) return;
    flag = false;
    setTimeout(() => {
      fn.apply(this, args);
      flag = true;
    }, ms);
  };
};
```



#### New

```javascript
const New = (fn, ...args) => {
  const obj = {};
  if (fn.prototype) {
    Object.setPrototypeOf(obj, fn.prototype);
  }
  const res = fn.apply(obj, args);
  if (typeof res === 'function' || (typeof res === 'object' && res !== null)) {
    return res;
  }
  return obj;
};
```



#### 数组去重

```javascript
const uniqueArr = (arr) => {
  return [...new Set(arr)];
};
```



#### 实现正则切分千分位



### ⭐️⭐️Medium

#### bind

```javascript
Function.prototype.bind2 = function (context) {
  if (typeof this !== 'function') {
    throw new Error('not a function');
  }
  const fn = this;
  const args = Array.from(arguments).slice(1);
  const resFn = function () {
    // 如果是new调用，则绑定this为实例对象，也就是new创建的新对象，否则返回context
    return fn.apply(this instanceof resFn ? this : context, args.concat(...arguments));
  };

  // 返回的新函数的原型继承原函数的原型
  resFn.prototype = Object.create(fn.prototype);

  return resFn;
};
```

#### call

```javascript
Function.prototype.call2 = function (context = window) {
  // 创建唯一的key，在context对象上创建一个指向函数的变量
  const key = Symbol('key');
  context[key] = this;
  const args = [...arguments].slice(1);
  const res = context[key](...args);
  delete context[key];
  return res;
};
```

#### apply

```javascript
Function.prototype.apply2 = function (context = window) {
  const key = Symbol('key');
  context[key] = this;
  const res = arguments[1] ? context[key](...arguments[1]) : context[key]();
  delete context[key];
  return res;
};
```

#### 深拷贝

```javascript
const deepCopy = function (obj, cache = new WeakMap()) {
  if (!obj instanceof Object) return obj;

  // 返回循环引用
  if (cache.has(obj)) {
    console.log(cache.get(obj));
    return cache.get(obj);
  }

  // 支持函数
  if (obj instanceof Function) {
    return function () {
      return obj.apply(this, arguments);
    };
  }
  // 支持日期
  if (obj instanceof Date) return new Date(obj);
  // 支持正则
  if (obj instanceof RegExp) return new RegExp(obj.source, obj.flags);

  const res = Array.isArray(obj) ? [] : {};
  cache.set(obj, res);

  Object.keys(obj).forEach((key) => {
    if (obj[key] instanceof Object) {
      res[key] = deepCopy(obj[key], cache);
    } else {
      res[key] = obj[key];
    }
  });
  return res;
};
```

#### 柯里化

```javascript
const curry = function (fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    }
    return function (...args2) {
      // 将之前的参数和现在的参数拼接上
      return curried.apply(this, args.concat(args2));
    };
  };
};
```



#### 继承

es5继承

```javascript
function Person(name) {
  this.name = name;
}
Person.prototype.sayName = function () {
  console.log(this.name);
};
function Children(name, age) {
  Person.call(this, name);
  this.age = age;
}
Children.prototype.sayAge = function () {
  console.log(this.age);
};
Object.setPrototypeOf(Children.prototype, Person.prototype);
Children.prototype.constructor = Children;

const zs = new Children('张三', 20);
zs.sayName();
zs.sayAge();
```

es6继承

```javascript
class Person {
  constructor(private name) {}
  sayName() {
    console.log(this.name);
  }
  static callMe() {
    console.log('callMe');
  }
}
class Children extends Person {
  constructor(name, private age) {
    super(name);
  }
  sayAge() {
    console.log(this.age);
  }
  static callMe() {
    console.log('callMe111');
  }
}

const zs = new Children('张三', 20);
zs.sayName();
zs.sayAge();
Children.callMe();
```



#### instanceof

```javascript
const _instanceOf = (left, right) => {
  let proto = left.__proto__;
  const prototype = right.prototype;
  while (true) {
    if (proto === null) return false;
    if (proto === prototype) return true;
    proto = proto.__proto__;
  }
};
```



#### 数组扁平化

```javascript
function flatter(arr) {
  if (!arr.length) return;
  return arr.reduce((pre, cur) => (Array.isArray(cur) ? [...pre, ...flatter(cur)] : [...pre, cur]), []);
}
```



#### 对象扁平化

```javascript
const flatter = (obj) => {
  const res = {};
  const process = (key, value) => {
    if (typeof value !== 'object') {
      res[key] = value;
    } else if (Object.prototype.toString.call(value) === '[object Object]') {
      const keyArr = Object.keys(value);
      keyArr.forEach((item) => {
        process(key ? `${key}.${item}` : `${item}`, value[item]);
      });
    } else if (Object.prototype.toString.call(value) === '[object Array]') {
      value.forEach((item, index) => {
        process(`${key}[${index}]`, item);
      });
    }
  };
  process('', obj);
  return res;
};
```



#### JSON.parse

```javascript
const parse = (target) => {
  return eval(`(${target})`);
};
```



#### JSON.stringify

```javascript
function getType(o) {
  return typeof o === 'symbol' ? 'Symbol_basic' : Object.prototype.toString.call(o).slice(8, -1);
}
function isObject(o) {
  return o !== null && (typeof o === 'object' || typeof o === 'function');
}
function processOtherTypes(target, type) {
  switch (type) {
    case 'String':
      return `"${target.valueOf()}"`;
    case 'Number':
    case 'Boolean':
      return target.valueOf().toString();
    case 'Symbol':
    case 'Error':
    case 'RegExp':
      return '{}';
    case 'Date':
      return `"${target.toJSON()}"`;
    case 'Function':
      return undefined;
    default:
      return null;
  }
}
function checkCircular(obj, currentParent) {
  let type = getType(obj);
  if (type == 'Object' || type == 'Array') {
    if (currentParent.includes(obj)) {
      throw new TypeError('Converting circular structure to JSON');
    }
    currentParent.push(obj);
  }
}
function jsonStringify(target, initParent = [target]) {
  let type = getType(target);
  let iterableList = ['Object', 'Array', 'Arguments', 'Set', 'Map'];
  let specialList = ['Undefined', 'Symbol_basic', 'Function'];
  if (!isObject(target)) {
    // symbol和undefined返回undefined
    if (type === 'Symbol_basic' || type === 'Undefined') {
      return undefined;
    }
    // NaN、Infinity和-Infinity返回"null"
    else if (Number.isNaN(target) || target === Infinity || target === -Infinity) {
      return 'null';
    }
    // string返回"string"
    else if (type === 'String') {
      return `"${target}"`;
    }
    return String(target);
  } else {
    let res;
    if (!iterableList.includes(type)) {
      // 其他对象类型
      res = processOtherTypes(target, type);
    } else {
      // 数组
      if (type === 'Array') {
        res = target.map((item) => {
          if (specialList.includes(getType(item))) {
            return 'null';
          } else {
            let currentParent = [...initParent];
            checkCircular(item, currentParent);
            return jsonStringify(item, currentParent);
          }
        });
        res = `[${res}]`.replace(/'/g, '"');
      } else {
        // Object
        res = [];
        Object.keys(target).forEach((key) => {
          if (getType(key) !== 'Symbol_basic') {
            let type = getType(target[key]);
            if (!specialList.includes(type)) {
              let currentParent = [...initParent];
              checkCircular(target[key], currentParent);
              res.push(`"${key}":${jsonStringify(target[key], currentParent)}`);
            }
          }
        });
        res = `{${res}}`.replace(/'/g, '"');
      }
    }
    return res;
  }
}
```



#### 事件触发器

```javascript
class EventEmitter {
  cache: Record<string, Function[]> = {};
  on(name: string, fn: Function) {
    const tasks = this.cache[name];
    if (!tasks) {
      this.cache[name] = [fn];
    } else {
      this.cache[name].push(fn);
    }
  }
  emit(name: string, once = false) {
    const tasks = this.cache[name].slice();
    if (tasks) {
      tasks.forEach((fn) => {
        fn();
      });
      if (once) {
        delete this.cache[name];
      }
    }
  }
  off(name: string, fn: Function) {
    const tasks = this.cache[name];
    if (tasks) {
      const index = tasks.findIndex((f) => f === fn);
      if (index !== -1) {
        tasks.splice(index, 1);
      }
    }
  }
}
```



#### 简单实现async/await中的async函数

```javascript
const async = (genertor) => {
  const iterator = genertor();

  function handle(iteratorResult) {
    if (iteratorResult.done) return;
    const itertorValue = iteratorResult.value;
    if (itertorValue instanceof Promise) {
      itertorValue.then((res) => handle(iterator.next(res))).catch((err) => iterator.throw(err));
    }
  }

  try {
    handle(iterator.next());
  } catch (error) {
    iterator.throw(error);
  }
};
```



#### 实现正则获取url params

✍️待补充

#### 实现jsonp

✍️待补充



### ⭐️⭐️⭐️Hard

#### Promise

```javascript
const PENDING = 'pending';
const FULFILLED = 'fulfilled';
const REJECTED = 'rejected';

const resolvePromise = (promise2, x, resolve, reject) => {
  if (promise2 === x) {
    return reject('111111');
  }
  if (x instanceof promise2) {
    x.then(resolve, reject);
  } else {
    resolve(x);
  }
};

class MyPromise {
  constructor(fn) {
    try {
      fn(this.resolve, this.reject);
    } catch (err) {
      this.reject(err);
    }
  }

  status = PENDING;
  value = null;
  reason = null;
  fulfilledList = [];
  rejectedList = [];

  resolve = (val) => {
    if (this.status === PENDING) {
      this.status = FULFILLED;
      this.value = val;
      while (this.fulfilledList.length) {
        this.fulfilledList.shift()(this.val);
      }
    }
  };

  reject = (reason) => {
    if (this.status === PENDING) {
      this.status = REJECTED;
      this.reason = reason;
      while (this.rejectedList.length) {
        this.rejectedList.shift()(this.reason);
      }
    }
  };

  then(fulfilledCallback, rejectedCallback) {
    const realFulfilledCallback = typeof fulfilledCallback === 'function' ? fulfilledCallback : (val) => val;
    const realRejectedCallback =
          typeof rejectedCallback === 'function'
    ? rejectedCallback
    : (reason) => {
      throw reason;
    };

    const promise2 = new MyPromise((resolve, reject) => {
      const microResolve = () => {
        queueMicrotask(() => {
          try {
            const x = realFulfilledCallback(this.value);
            resolvePromise(promise2, x, resolve, reject);
          } catch (err) {
            reject(err);
          }
        });
      };
      const microReject = () => {
        queueMicrotask(() => {
          try {
            const x = realRejectedCallback(this.reason);
            resolvePromise(promise2, x, resolve, reject);
          } catch (err) {
            reject(err);
          }
        });
      };

      if (this.status === FULFILLED) {
        microResolve();
      } else if (this.status === REJECTED) {
        microReject();
      } else {
        this.fulfilledList.push(microResolve);
        this.rejectedList.push(microReject);
      }
    });
    return promise2;
  }

  catch = (rejectedCallback) => {
    this.then(null, rejectedCallback);
  };

  static resolve(val) {
    return new MyPromise((resolve) => {
      resolve(val);
    });
  }

  static reject(reason) {
    return new MyPromise((resolve, reject) => {
      reject(reason);
    });
  }

  static all(list) {
    let resList = [];
    let count = 0;
    return new MyPromise((resolve, reject) => {
      for (let i = 0; i < list.length; i++) {
        list[i]
          .then((val) => {
          resList[i] = val;
          count++;
          if (count === list.length) {
            resolve(resList);
          }
        })
          .catch((err) => {
          reject(err);
        });
      }
    });
  }

  static rare(list) {
    return new MyPromise((resolve, reject) => {
      for (let i = 0; i < list.length; i++) {
        list[i]
          .then((val) => {
          resolve(val);
        })
          .catch((err) => {
          reject(err);
        });
      }
    });
  }
}
```

